import java.io.*;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;

public class EA_triples_ljiang {
	
	public static class gametime
	{
		String  game;
		Long	time;
	}
	
	public static class gametriple
	{
		String game1;
		String game2;
		String game3;
	}
	
	public static ArrayList<Long> alltriples;
	public static ArrayList<Integer> allcounts;
	
	//dictionary for searching for games --- each game is indexed as an integer
	public static HashSet<String> gameset;
	public static HashMap<String, Integer> gamedict;
	public static ArrayList<String> revgamedict;
	
	public static class MultiFileLocks {
		private static HashSet<String> filepool;
		
	    MultiFileLocks()
	    {
	    	filepool = new HashSet<String>();
	    }

	    public synchronized void lock(String infile) throws InterruptedException {
	        while(filepool.contains(infile)) {
	        		wait();      		
	        }
	        filepool.add(infile);
	    }

	    public synchronized void unlock(String infile) {
	    	if(filepool.contains(infile))
	    	{
	    		filepool.remove(infile);
	    	}
	    	else
	    	{
	    		System.out.printf("%s not in the filepool \n", infile);
	    	}
	        notifyAll();
	    }
	}
	
	private final static MultiFileLocks locks =new MultiFileLocks();
	
	public static class ReadThread extends Thread
	{
		private String filename = "";
		private Integer torder = -1;
		
		ReadThread(String name, int num)
		{
			 filename = name;
			 torder = num;
		}
		
		//read a small file (after partitioning) and write all the updates into userfiles (all userfiles end with ".eauser")
		public void readFile(String filename, Integer num) throws IOException
		{
			File file = new File(filename+num.toString());
			BufferedReader input = new BufferedReader(new FileReader(file));
			try {
				String line = null;
				while((line = input.readLine()) != null)
				{
					if(line.length() <= 1)
						continue;
					String [] strsplit;
					strsplit = line.split("\t");
					String user = strsplit[0];
					String game = strsplit[1];
					Long time = Long.parseLong(strsplit[2]);
					gametime newelem = new gametime();
					newelem.game = game;
					newelem.time = time;
					//find the user and the correponding history (if available)
					ArrayList<gametime> olduserelem;
					String userfilename = user;
					//create the use directory by thread
					File tmpdir = new File("userprofiles\\"+num.toString());
					if(!tmpdir.exists())
					{
						tmpdir.mkdirs();
					}
					else if(!tmpdir.isDirectory())
					{
						tmpdir.delete();
						tmpdir.mkdirs();
					}
					boolean exists = (new File("userprofiles\\"+num.toString()+"\\"+userfilename+"_"+num.toString()+".eauser")).exists();
					if(exists)
						olduserelem = readUserElems(num, userfilename);	
					else
						olduserelem = new ArrayList<gametime>();
					//lock.unlock();
					int inspos = findInsPos(olduserelem, time);
					if(inspos >= 0)
						olduserelem.add(inspos, newelem);
					else
						System.out.printf("something is wrong here: can't find a position for time %d game %s user %s \n", time, game, user);
					//System.out.printf("%s ... %s\n", user, game);
					writeUserElems(user, olduserelem, num);
				}		
			} 
			finally {
				input.close();
				//delete the file generated by partitioning the big data input
				file.delete();
			}
		}

		@Override
		public void run() {
			// TODO Auto-generated method stub
			try {
				readFile(filename, torder);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} 
		}
		
	}
	
	//thread used for combining user files
	public static class CombThread extends Thread
	{
		private Integer torder = -1;
		private ArrayList<gametime> userelems;
		
		CombThread(Integer num)
		{
			torder = num;
			userelems = new ArrayList<gametime>();
		}
		
		@SuppressWarnings("unchecked")
		public void combineUserRecords(String name, Integer num)
		{
			//read the global user file if it exists
			ArrayList<gametime> globalelems;
			File tmpfile = new File("userprofiles\\"+name+".eauser");
			boolean exists = tmpfile.exists() && tmpfile.isFile();
			if(!exists)
			{
				// then write it to a single file
				FileWriter fstream;
				try {
					fstream = new FileWriter("userprofiles\\" + name
							+ ".eauser");
					BufferedWriter out = new BufferedWriter(fstream);
					for (int i = 0; i < userelems.size(); i++) {
						out.write(userelems.get(i).game + "\t"
								+ userelems.get(i).time.toString() + "\n");
					}
					out.close();
				} catch (IOException e) {
					System.err.println("Error: " + e.getMessage());
				}
			}
			else
			{
				//read the globalfile
				try {
					globalelems = readUserElems(-1, name);
					//print out all the elements for debugging
					/*System.out.printf("thread %d --- %s already has ", torder, name);
					for(gametime tmpelem:globalelems)
					{
						System.out.printf("%s:%s ", tmpelem.game, tmpelem.time.toString());
					}
					System.out.printf("\n");*/
					//merge two sorted files
					int tmppivot = 0;
					for(int i=0; i< userelems.size(); i++)
					{
						while(tmppivot < globalelems.size() && userelems.get(i).time > globalelems.get(tmppivot).time)
							tmppivot++;
						globalelems.add(tmppivot, userelems.get(i));
						if(tmppivot < globalelems.size()-1)
							tmppivot++;
					}
					//write the new global file
					writeUserElems(name, globalelems, -1); 
					/*System.out.printf("%s now has ", name);
					for(gametime tmpelem:globalelems)
					{
						System.out.printf("%s:%s ", tmpelem.game, tmpelem.time.toString());
					}
					System.out.printf("\n");*/
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
				
			}
		}
		
		public void run()
		{
			String path = "userprofiles";
	 		File subfolder = new File(path+"\\"+torder.toString());
	 		if(!(subfolder.exists() && subfolder.isDirectory()))
	 		{
	 			System.out.printf("subfolder doesn't exist: %s \n", path+"\\"+torder.toString());
	 			return;
	 		}
	 		
	 		for( File tmpfile:subfolder.listFiles())
	 		{
	 			String infilename = tmpfile.getName();
	 			String[] tmpsplit = infilename.split("\\.");
	 			tmpsplit = tmpsplit[0].split("_");
	 			infilename = tmpsplit[0];	
	 			try {
	 				locks.lock(infilename);
	 				userelems = readUserElems(torder, infilename);
	 				//for debugging
	 				/*System.out.printf("thread %d --- %s just read ", torder, infilename);
					for(gametime tmpelem:userelems)
					{
						System.out.printf("%s:%s ", tmpelem.game, tmpelem.time.toString());
					}
					System.out.printf("\n");*/
					combineUserRecords(infilename, torder);
		 			locks.unlock(infilename);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
	 			tmpfile.delete();
	 		}
	 		subfolder.delete();
		}
	}
	
	//read the existing user sequence from file on disk
	public static ArrayList<gametime> readUserElems(Integer num, String filename) throws IOException
	{
		ArrayList<gametime> newelems = new ArrayList<gametime>();
		File file;
		if(num >= 0)
			file = new File("userprofiles\\"+num.toString()+"\\"+filename+"_"+num.toString()+".eauser");
		else
			file = new File("userprofiles\\"+filename+".eauser");
		BufferedReader input = new BufferedReader(new FileReader(file));
		try {
			String line = null;
			while((line = input.readLine()) != null)
			{
				if(line.length() <= 1)
					continue;
				String [] strsplit;
				strsplit = line.split("\t");
				gametime tmpelem = new gametime();
				tmpelem.game = strsplit[0];
				tmpelem.time = Long.parseLong(strsplit[1]);
				newelems.add(tmpelem);
			}
		}
		finally{
			input.close();
		}
		return newelems;
	}
		
	//when new item (game+time) is added, re-write the user files
	public static void writeUserElems(String name, ArrayList<gametime> elems, Integer num) 
	{
		//check target folder
		File dir;
		if(num >= 0)
			dir = new File("userprofiles\\"+num.toString());
		else
			dir = new File("userprofiles");
		if(!(dir.exists() && dir.isDirectory()))
		{
			if(num >= 0)
				System.out.printf("the directory doesn't exist: %s \n", "userprofiles\\"+num.toString());
			else
				System.out.printf("the directory doesn't exist: useprofiles \n");
			if(dir.exists() && !dir.isDirectory())
				dir.delete();
			dir.mkdirs();
			return;
		}
		FileWriter fstream;	
		try {
			if(num >= 0)
				fstream = new FileWriter("userprofiles\\"+num.toString()+"\\"+name+"_"+num.toString()+".eauser");
			else
				fstream = new FileWriter("userprofiles\\"+name+".eauser");
			BufferedWriter out = new BufferedWriter(fstream);
			for(int i=0; i< elems.size(); i++)
			{
				out.write(elems.get(i).game+"\t"+elems.get(i).time.toString()+"\n");
			}
			out.close();
		} catch (IOException e) {
			System.err.println("Error: "+ e.getMessage());
		}	
	}
	
	//conversion between gametriple (three  games) and a long-type index
	//e.g. if there are 4 games, {1,3,2} = 1*4*4+3*4+2 = 30
	public static Long triple2long(gametriple triple)
	{
		Long total = 0L;
		int gamesize = gamedict.size();
		int ind1 = gamedict.get(triple.game1);
		total+= (long)ind1*(long)gamesize*(long)gamesize;
		int ind2 = gamedict.get(triple.game2);
		total+= (long)ind2*(long)gamesize;
		int ind3 = gamedict.get(triple.game3);
		total+= (long)ind3;
		return total; 
	}
	
	public static gametriple long2triple(Long value)
	{
		int gamesize = gamedict.size();
		gametriple tmpt = new gametriple();
		int ind1 = (int) (value/(gamesize*gamesize));
		value -= (long)ind1*(long)gamesize*(long)gamesize;
		int ind2 = (int)(value/gamesize);
		value -= (long)ind2*(long)gamesize;
		int ind3 = (int) (value/1);
		tmpt.game1 = revgamedict.get(ind1);
		tmpt.game2 = revgamedict.get(ind2);
		tmpt.game3 = revgamedict.get(ind3);
		return tmpt;
	}
	
	public static void init()
	{
		alltriples = new ArrayList<Long>();
		allcounts = new ArrayList<Integer>();
		gameset = new HashSet<String>();
		gamedict = new HashMap<String, Integer>();
		revgamedict = new ArrayList<String>();
	}
	
	//partition the big file into small files (the number of portions is defined by user)
	public static int partitionFile(String filename, int parnum) throws IOException
	{
		File file = new File(filename);
		BufferedReader input = new BufferedReader(new FileReader(file));
		Long linecount = 0L;
		try {
			String line = null;
			while((line = input.readLine()) != null)
			{
				if(line.length() <= 1)
					continue;
				linecount++;
			}
		}
		finally{
			input.close();
		}
		
		Long parlinenum = linecount/parnum;
		while(linecount - parlinenum*parnum >= parnum/2)
			parlinenum = parlinenum+1L;
		FileWriter fstream;	
		ArrayList<BufferedWriter> newout = new ArrayList<BufferedWriter>();
		for(Integer  i=0; i< parnum; i++)
		{	
			String newfilename = filename+i.toString();
			fstream = new FileWriter(newfilename);
			BufferedWriter tmpout = new BufferedWriter(fstream);
			newout.add(tmpout);
		}
		
		Long newlinecount = 0L;
		int curpar = 0;
		input = new BufferedReader(new FileReader(file));
		try {
			String line = null;
			BufferedWriter curout = newout.get(curpar);
			while((line = input.readLine()) != null)
			{
				if(line.length() <= 1)
					continue;
				//extract the line and add game to dictionary, if a new game
				String [] strsplit;
				strsplit = line.split("\t");
				String game = strsplit[1];
				synchronized(gameset)
				{
					if(!gameset.contains(game))
					{
						gameset.add(game);
						Integer tmppos = findDictInsPos(game);
						revgamedict.add(tmppos, game);
					}
				}
				curout.write(line+"\n");
				newlinecount++;
				if(newlinecount >= parlinenum && curpar < parnum-1)
				{
					curout.close();
					newlinecount = 0L;
					curpar++;
					curout = newout.get(curpar);
				}
			}
			curout.close();
			int actpar = curpar+1;
			for(; curpar <= parnum-1; curpar++)
				newout.get(curpar).close();
			//get the game dictionary numbers in alphabatical order
			for(Integer i=0; i< revgamedict.size(); i++)
			{
				gamedict.put(revgamedict.get(i), i);
			}
			return actpar;
		}
		finally{
			input.close();
		}
	}

	//a binary search to locate where to insert a new time stamp (assuming a user can't play two games at the same time)
	public static int findInsPos(ArrayList<gametime> elems, Long newtime)
	{
		//binary search
		if(elems.size() < 1)
			return 0;
		int lo = 0;
		int hi = elems.size()-1;
		if(newtime.longValue() <= elems.get(lo).time.longValue())
			return 0;
		else if(newtime.longValue() >= elems.get(hi).time.longValue())
			return elems.size();
		while(lo <= hi)
		{
			int mid = lo + (hi-lo)/2;
			if(hi -lo >= 2)
			{
				if(newtime.longValue() > elems.get(mid).time.longValue())
					lo = mid;
				else if(newtime.longValue() < elems.get(mid).time.longValue())
					hi = mid;
				else
					return mid;
			}
			else
			{
				if(newtime.longValue() <= elems.get(lo).time.longValue())
					return lo;
				else if(newtime.longValue() <= elems.get(hi).time.longValue())
					return hi;
				else
				{
					System.out.printf("there is something wrong!!! \n");
					return -1;
				}
			}
		}
		return -1;
	}
	
	//a binary search to locate where to insert a new time stamp (assuming a user can't play two games at the same time)
		public static int findDictInsPos(String newname)
		{
			//binary search
			ArrayList<String> elems = revgamedict;
			if(elems.size() < 1)
				return 0;
			int lo = 0;
			int hi = elems.size()-1;
			if(newname.compareTo(elems.get(lo)) <= 0)
				return 0;
			else if(newname.compareTo(elems.get(hi)) >=0)
				return elems.size();
			while(lo <= hi)
			{
				int mid = lo + (hi-lo)/2;
				if(hi -lo >= 2)
				{
					if(newname.compareTo(elems.get(mid)) > 0)
						lo = mid;
					else if(newname.compareTo(elems.get(mid)) < 0)
						hi = mid;
					else
						return mid;
				}
				else
				{
					if(newname.compareTo(elems.get(lo)) <= 0)
						return lo;
					else if(newname.compareTo(elems.get(hi)) <= 0)
						return hi;
					else
					{
						System.out.printf("there is something wrong!!! \n");
						return -1;
					}
				}
			}
			return -1;
		}
	
	//a binary search variant to detect whether the triple exists (if not, return -1; if yes, return the position in the array)
	public static int tripleExists(ArrayList<Long> elems, Long newvalue)
	{
		//binary search
		if(elems.size() < 1)
			return -1;
		int lo = 0;
		int hi = elems.size()-1;
		if(newvalue.longValue() < elems.get(lo).longValue())
			return -1;
		else if(newvalue.longValue() > elems.get(hi).longValue())
			return -1;
		while(lo <= hi)
		{
			int mid = lo + (hi-lo)/2;
			if(hi -lo >= 2)
			{
				if(newvalue.longValue() > elems.get(mid).longValue())
					lo = mid;
				else if(newvalue.longValue() < elems.get(mid).longValue())
					hi = mid;
				else
					return mid;
			}
			else
			{
				if(newvalue.longValue() != elems.get(lo).longValue())
				{
					if(newvalue.longValue() != elems.get(hi).longValue())
						return -1;
					else
						return hi;	
				}
				else
				{
					return lo;
				}
			}
		}
		return -1;
	}
	
	//by calling tripleExists first, it find out the insertion position if it is a new triple
	public static int tripleInsPos(ArrayList<Long> elems, Long newvalue)
	{
		//binary search
		if(elems.size() < 1)
			return 0;
		int lo = 0;
		int hi = elems.size()-1;
		if(newvalue.longValue() <= elems.get(lo).longValue())
			return 0;
		else if(newvalue.longValue() >= elems.get(hi).longValue())
			return elems.size();
		while(lo <= hi)
		{
			int mid = lo + (hi-lo)/2;
			if(hi -lo >= 2)
			{
				if(newvalue.longValue() > elems.get(mid).longValue())
					lo = mid;
				else if(newvalue.longValue() < elems.get(mid).longValue())
					hi = mid;
				else
					return mid;
			}
			else
			{
				if(newvalue.longValue() < elems.get(lo).longValue())
					return lo;
				else if(newvalue.longValue() < elems.get(hi).longValue())
					return hi;
				else
				{
					System.out.printf("there is something wrong!!! --triple \n");
					return -1;
				}
			}
		}
		return -1;
	}
	
	//get all the triples from a userfile and get the count
	public static void findUserTriples(String filename) throws IOException
	{
		String newfilename = filename;
		if(filename.endsWith(".eauser"))
		{
			String[] tmpstrs;
			tmpstrs = filename.split("\\.");
			newfilename = tmpstrs[0];
		}
		FileWriter fstream;	
		fstream = new FileWriter("userprofiles\\"+newfilename+".tpl");
		BufferedWriter out = new BufferedWriter(fstream);	
		ArrayList<gametime> userelems = readUserElems(-1, newfilename);
		if(userelems.size() < 3)
			return;
		synchronized(alltriples)
		{
			for (int i = 0; i <= userelems.size() - 3; i++) {
				gametriple tmpt = new gametriple();
				tmpt.game1 = userelems.get(i).game;
				tmpt.game2 = userelems.get(i + 1).game;
				tmpt.game3 = userelems.get(i + 2).game;
				out.write("("+tmpt.game1+","+tmpt.game2+","+tmpt.game3+")\n");
				Long tmpvalue = triple2long(tmpt);
				int existpos = tripleExists(alltriples, tmpvalue);
				if (existpos >= 0) {
					Integer tmpcount = allcounts.get(existpos);
					allcounts.set(existpos, tmpcount + 1);
				} else {
					int tmppos = tripleInsPos(alltriples, tmpvalue);
					alltriples.add(tmppos, tmpvalue);
					allcounts.add(tmppos, 1);
				}
			}
		}
		out.close();
	}
	
	public static void writeAllTriples(String name)
	{
		FileWriter fstream;	
		try {
			fstream = new FileWriter(name);
			BufferedWriter out = new BufferedWriter(fstream);
			for(int curindex =0; curindex < alltriples.size(); curindex++)
			{
				gametriple tmptriple = long2triple(alltriples.get(curindex));
				String tmpstr1 = tmptriple.game1;
				String tmpstr2 = tmptriple.game2;
				String tmpstr3 = tmptriple.game3;
				out.write("("+ tmpstr1+ ","+tmpstr2+","+tmpstr3+")");
				out.write("\t"+allcounts.get(curindex).toString());
				out.write("\n");
			}
			out.close();
		} catch (IOException e) {
			System.err.println("Error: "+ e.getMessage());
		}	
	}
	
	public static void main(String[] args)
	{
		 init();
		 try {
			 	int chunknum = 4;
			 	String bigfilename = "bigtest";
			 	String outfilename = "output2";
			 	if(args.length > 2)
			 	{
			 		bigfilename = args[0];
			 		chunknum = Integer.parseInt(args[1]);
			 		outfilename = args[2];
			 	}
			 	chunknum = partitionFile(bigfilename, chunknum);
			 	
			 	List<Thread> threads = new ArrayList<Thread>();
			 	for(Integer i=0; i< chunknum; i++)
			 	{
			 		Thread worker = new ReadThread(bigfilename, i);
			 		threads.add(worker);
			 	}
			 	
			 	for(Thread thread: threads)
			 	{
			 		thread.start();
			 	}
			 	
			 	for (Thread thread:threads)
			 	{
			 		thread.join();
			 	}
			 	
			 	//just print out the size of game dictionary
			 	System.out.printf("the size of game dictionary: %d\n", gamedict.size());
			 	
				//then move to the part of combining user profiles, which locks are needed (one for each file)
			 	//MultiFileLocks locks = new MultiFileLocks(chunknum);
			 	//CombThreads
			 	List<Thread> newthreads = new ArrayList<Thread>();
			 	for(Integer i=0; i< chunknum; i++)
			 	{
			 		Thread worker = new CombThread(i);
			 		newthreads.add(worker);
			 	}
			 	
			 	for(Thread thread: newthreads)
			 	{
			 		thread.start();
			 	}
			 			 	 	
			 	for (Thread thread:newthreads)
			 	{
			 		thread.join();
			 	}
			 	
				String path = "userprofiles"; 
			 	
			 	File folder = new File(path);
				File[] listOfFiles = folder.listFiles(); 
				 
				for (int i = 0; i < listOfFiles.length; i++) 
				{
				   if (listOfFiles[i].isFile() && listOfFiles[i].getName().endsWith(".eauser")) 
				   {
					      findUserTriples(listOfFiles[i].getName());
				   }
				}
				writeAllTriples(outfilename);
				
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
	  }
}
